---------------------------------------------------------
[E7] 第6章 配列(2) に関する考察・感想用テンプレート
---------------------------------------------------------

課題： E7
学生番号： 37022503
氏名： 山形隼士
作成日： 5/28

（注意）【以下は確認の上，消去してからレポート提出を行って下さい】
  ・ プログラミングの力がつかないため，他の学生・先輩などが作成したプ
       ログラムをコピーすることは厳禁です．

  ・ 各課題に対して，
      - 学習内容（どのようなプログラムを作成したか，この課題を通して学んだ事項，
           作成中に間違えた箇所，など）
      - 結果（結果を報告する．実行結果も貼り付けよ）
      - 習得した内容，苦労した点，工夫した点，考察など
     について必ず記すこと．

  ・ プログラムが完成次第，1問ごとにその都度以下のレポート欄に
       記入して下さい．あとからまとめて記そうとすると，書くべき事項を
       忘れることが多くあります．

-----------------------------------------------
(E7_1)

学習内容：
漸化式 ai = 2 ai-1 + 1 に従う数列 {ai} ( i ≥ 0 ) の各項を配列に格納するプログラムを作成せよ．以下では，ai を配列の要素 a[ i ] に格納する．

マクロ定数 N を 20 とし，要素数が N である配列 a を定義する．
キーボードから整数を1個受け取り，これを a[ 0 ] に代入する．
漸化式に従って，for 文を用いて，a[1], ..., a[N-1] の値を順に計算して代入せよ．
配列 a の計算結果を用いて，a0, ..., aN-1 をすべて表示せよ．

表示例は以下の通り(数字は正しいとは限らない)：
a_0 = 5 
a_1 = 11 
a_2 = 23 
: 

結果：
a[0] = 10
a[1] = 21
a[2] = 43
a[3] = 87
a[4] = 175
a[5] = 351
a[6] = 703
a[7] = 1407
a[8] = 2815
a[9] = 5631
a[10] = 11263
a[11] = 22527
a[12] = 45055
a[13] = 90111
a[14] = 180223
a[15] = 360447
a[16] = 720895
a[17] = 1441791
a[18] = 2883583
a[19] = 5767167

習得した内容・反省・考察など：
漸化式に従う数列を出力することができた。この課題では各校を出力するだけであったが、この課題の内容を改良することで総和を求めるプログラムも作成することができると思う。

-----------------------------------------------
(E7_2) 

学習内容：
配列の大きさよりデータの個数が少ない場合，データの終わりを示す目印であるターミネータ（番兵（ばんぺい）とも言う，p. 261参照）が有用となる． 
0 以上の整数の 2乗のうち， n 以下であるような数を小さい順に配列 a に格納するプログラムを以下の通り作成せよ． ここでは，整数の2乗が負とならない事実に基づいて，データとして生じえない -1 をターミネータとして用いる． 

キーボードから 2000 以下の正の整数 n を受け取る．また，int 型の配列 a[50] を定義する（配列の要素数は余裕をもって大きく設定している）．
i2 が n 以下であることを境界条件として， i2 を a[i] に順に代入する．すなわち，a[0] = 0, a[1] =1, a[2] = 4, a[3] = 9, ...
(i-1)2 ≤ n かつ i2 > n となる整数 i について，a[ i ] = -1; としてターミネータを代入せよ．
配列 a の要素を先頭から順に表示せよ．ただし，配列の要素がターミネータと一致した時点で表示を終了する（6.6.1項, p. 261参照）．
正の整数の 2 乗であり，かつ n 以下であるような数の和を配列 a に格納された数値を用いて計算し表示せよ．前問同様，ターミネータと一致した時点で加算を終了すればよい．
n = 50 なら，a[0] = 0, a[1] = 1, a[2] = 4, ..., a[7] = 49, a[8] = -1 であり (a[8] は表示しない)，2乗の和は 140 となる．

結果：
Please enter the number>>>200
0
1
4
9
16
25
36
49
64
81
100
121
144
169
196
The sum is 1015

習得した内容・反省・考察など：
今回の課題ではターミネーターというものを導入して作成することができた。データの境目を認識する上で非常に有用であると感じたため、for文やwhile文の中に入れ込んで使えるようにしていきたい。

-----------------------------------------------
(E7_3) 

学習内容：
与えられた3次正方行列の転置行列を求めて表示するプログラムを作成する．

与えられた M次正方行列 A に対して，その転置行列 B = AT をfor 文による2重ループを使用して求める．A の (i, j)成分と B の (j, i) 成分が等しいことに注意せよ．
行列 B を print_array 関数に渡して表示する．print_array 関数は以前の課題で作成したものを使用する．
行列 A，B はそれぞれプログラム内で配列 a, b で表されるとする．
#include <stdio.h>
#include <math.h>

#define M 3

void print_array( double a[M][M] ){
        // 以前の課題で作成した print_array 関数をここで使用する
}

int main ( void )
{
	double a[ M ][ M ], b[ M ][ M ];
	int i, j;

	a[0][0] = -1.0/sqrt(2.0);  a[0][1] = -1.0/sqrt(3.0);  a[0][2] = 1.0/sqrt(6.0);
	a[1][0] =  1.0/sqrt(2.0);  a[1][1] = -1.0/sqrt(3.0);  a[1][2] = 1.0/sqrt(6.0);
	a[2][0] =  0.0;            a[2][1] =  1.0/sqrt(3.0);  a[2][2] = 2.0/sqrt(6.0);

	// ここで行列 B を求める

        // print_array 関数を呼び出して行列 B を表示する

	return 0;
}

結果：
 -0.7  -0.6   0.4 
  0.7  -0.6   0.4 
  0.0   0.6   0.8 

 -0.7   0.7   0.0 
 -0.6  -0.6   0.6 

習得した内容・反省・考察など：
for文の中で、A の (i, j)成分と B の (j, i) 成分を入れ替えることで、転置行列を描画することができた。forループのどの数字が変化しているのかを確認しながらコードを書いていきたい。

-----------------------------------------------
(E7_4) 

学習内容：
正方行列とその転置行列の積を計算するプログラムを完成せよ．

以下のプログラム内で与えられた M 次正方行列 B = AT は確かに行列 A の転置行列であることを目視で確認せよ．
[リスト6.13] を参考にして，行列 A と B の積 C = A B を計算する．
行列 C を関数 print_array を用いて表示する．
[リスト6.13] を参考にして，行列 B と A の積 D = B A を計算する（注： 一般には，A B = B A は成り立たない）．
行列 D を関数 print_array を用いて表示する．
ただし，行列 A，B，C, D はそれぞれプログラム内で配列 a, b, c, d で表されるとする． 
[リスト6.13] のプログラムでは，行列の積を計算する上で 3重ループが用いられている．どのような計算が行われて行列の積が求められているかをレポートにて説明すること．
行列 C および D の計算を行う上で，各要素に対して初期化が必要となる．[リスト6.13] のプログラムではどのように初期化がされているかをレポートで説明せよ．
計算結果から，下のプログラムで示された行列 A はどのような行列であるか，線形代数の観点からレポートに記せ．
#include <stdio.h>
#include <math.h>

#define M 3

void print_array( double a[M][M] ){
        // 以前の課題で作成した print_array 関数をここで使用する
}

int main ( void )
{
	double a[ M ][ M ], b[ M ][ M ], c[ M ][ M ], d[ M ][ M ];
	int i, j, k;

	a[0][0] = -1.0/sqrt(2.0);  a[0][1] = -1.0/sqrt(3.0);  a[0][2] = 1.0/sqrt(6.0);
	a[1][0] =  1.0/sqrt(2.0);  a[1][1] = -1.0/sqrt(3.0);  a[1][2] = 1.0/sqrt(6.0);
	a[2][0] =  0.0;            a[2][1] =  1.0/sqrt(3.0);  a[2][2] = 2.0/sqrt(6.0);

	b[0][0] = -1.0/sqrt(2.0);  b[0][1] =  1.0/sqrt(2.0);  b[0][2] = 0.0;
	b[1][0] = -1.0/sqrt(3.0);  b[1][1] = -1.0/sqrt(3.0);  b[1][2] = 1.0/sqrt(3.0);
	b[2][0] =  1.0/sqrt(6.0);  b[2][1] =  1.0/sqrt(6.0);  b[2][2] = 2.0/sqrt(6.0);


	// ここで行列の積 C = A B を求める

        print_array( c );

	// ここで行列の積 D = B A を求める

        print_array( d );

	return 0;
}

結果：
1.0   0.0   0.0 
0.0   1.0   0.0 
0.0   0.0   1.0 

1.0   0.0   0.0 
0.0   1.0   0.0 
0.0   0.0   1.0 

習得した内容・反省・考察など：
リスト13においては、forループの二重ループの中で初期化をしている。このようにすることで、まずc[0][0]が初期化せれ、その後c[0][1]が初期化されていく。また、出力された数列は階段行列となる。

-----------------------------------------------
(E7_5) 

学習内容：
複数の点の座標が与えられたとき，各点の距離の最小値とそれを与える点の組を求めるプログラムを作成する．

[リスト 6.14]のプログラムを入力し実行せよ．ただし，
各配列の初期値はキーボードから入力させるのではなく，プログラムの中で初期化するように変更する．データは教科書表6.4と同一とし，6.6.1項を参考にすると初期化は下のように行える．
    int seat_no[ MAX_SEAT ] = { 1, 5, 8, 10, 15, 16, 20, 22, 25, 30 };
    double point[ MAX_SEAT ][ 2 ] =
    {
      { 1.1, 5.2 },
      { 3.4, 1.6 },
      { 4.5, 3.4 },
      { 2.3, 2.6 },
      { 6.4, 5.7 },
      { 7.6, 7.8 },
      { 5.2, 4.4 },
      { 1.7, 3.5 },
      { 3.8, 6.3 },
      { 5.8, 6.3 },
    };

実行して結果を確認せよ．
結果が正しく表示されることを確認した後，for 文のカウンタ変数 j の初期値を j = i+1 に変更した上で再度コンパイル・実行して見よ．もし正しく動作するならば，この変更の意味をレポートにて説明せよ． 
（本来，[リスト 6.14]は "j = i+1" と書かれるべきと思われます．しかし，"j = 0" としている著者らの意図は不明です(課題ページからリンクされた教科書正誤表でも記されています)）．

上のプログラム（ j = i+1 に変更したもの）に対して，次のような変更を加えよ．
[リスト 6.14] は距離が最も大きい2個の空席の組を求めて表示するプログラムであった．これを変更して異なる2個の空席の組のうち，距離が最も小さいものを求めて表示するプログラムを作成し，これを提出せよ．変更すべき点に以下が挙げられる．
変数 max_dis および配列 max_dis_seat の名称はそれぞれ，min_dis，min_dis_seat に変更することが自然である
最小値を求めるため，min_dis の初期値は十分大きな値とする必要がある．例えば，[リスト 6.5]における初期化が参考になる．
[リスト 6.14] では距離の最大値を求めている．これに対して，今回は距離の最小値を求めるため，変更が必要となる箇所がある．
[リスト 6.14]のプログラムに以上の変更を施した上でコンパイル・実行せよ．
正しく動作した場合，for 文のカウンタ変数 j の初期値を j = i+1 から，教科書[リスト 6.14]と同じく j = 0 に変更して実行せよ．結果が正しくない場合，その理由を考察して説明せよ（提出の際には，j = i+1 に戻しておくこと）

結果：
最も離れた座席は 15 と 30 です (距離 0.848528)

習得した内容・反省・考察など：
forループのjの初期値をi + 1にすることで、ひとつ目の座席と、二つ目の座席の距離を計算することができる。また、j=0としてしまうと、ひとつ目とひとつ目の座席の距離を計算してしまうことになり、結果的に距離は0という出力をしていた。

-----------------------------------------------
(E7_6) 

学習内容：
以下のプログラムでは，10点満点のテストを受験した50人分の点数が配列 score に格納されている． このテストの点数について，度数分布を求めて表示せよ．つまり，0 点の人数，1 点の人数，2 点の人数，...，10 点の人数をそれぞれ求めて表示する． 
度数分布の作成の上で以下に注意せよ．

配列 freq の要素 freq[ i ] には，i 点の人数が格納される．
従って，1点の人が見つかれば freq[ 1 ]++; 4点の人が出れば freq[ 4 ]++;，…のようにして人数の計算が行える．
配列 score の要素は score[ 0 ] = 1 (点)，score[ 1 ] = 4 (点), … , score[49] = 5 (点) であるから，freq[ score[i] ]++; を i = 0, ..., NUM_SCORE-1 について繰り返すことで度数分布を求められる
#include <stdio.h>

#define N 10
#define NUM_SCORE 50

int main ( void ) 
{

	int i;
	int score[ NUM_SCORE ] = {
		1,  4,  9,  9,  8, 10, 10,  9,  5, 10, 
		2,  9,  6,  4,  0,  7,  3,  5,  6,  6, 
		7,  4,  2,  9,  2,  5,  5,  3,  1,  9, 
		5,  7,  3,  2,  7,  9,  1,  7,  6,  6, 
		5,  8,  2,  5,  3, 10,  6,  2,  2,  5, 
	};

	int freq[ N+1 ]; /* 点数 i の学生の人数を格納する配列 freq[i] */

	for( i = 0; i <= N; i++ )
		freq[ i ] = 0;


        // ここで度数分布を求める


	// 結果の表示
	printf("点数の分布は以下の通りです．\n");
	for ( i = 0; i <= N; i++ ) 
	{
		printf(" %2d点: %d\n ", i, freq[i] );
	}


	return 0;

}

結果：
　0点: 1
   1点: 3
   2点: 7
   3点: 4
   4点: 3
   5点: 7
   6点: 6
   7点: 5
   8点: 2
   9点: 7
  10点: 4

習得した内容・反省・考察など：
少し前の課題で作成した、入力された値の数を出力するプログラムを参考にして作成することができた。freq[score]++とすることで、入力された値の数の度数分布を求めることができた。

-----------------------------------------------
(E7_7) 

学習内容：
以下のプログラムの配列 a には，M 人が受験し， N 回実施された試験の点数が格納されている．ただし，各自の学生番号は 0, 1, ..., M-1 であるとし，試験の回数は簡単のため 0, 1, ..., (N-1) 回目と数えることとする． 
例えば，a[ i ][ j ] は，学生番号が i である人が受験した j 回目の試験の点数を表す．以下を計算して表示するプログラムを for 文を用いて作成せよ．

各学生が N 回の試験でとった点数の平均点
各回の試験における M 人の学生の平均点

表示例：
学生0の平均点は 81.25
学生1の平均点は 45.00
学生2の平均点は 56.25
学生3の平均点は 88.75
学生4の平均点は 75.00

0回目の試験の平均点は 67.00
1回目の試験の平均点は 73.00
2回目の試験の平均点は 65.00
3回目の試験の平均点は 72.00
#include <stdio.h>

#define M 5
#define N 4

int main( void )
{
	int i, j;
	int sum;
	double average;
        // 使用しない変数は消去すること

	int a[ M ][ N ] = { { 70,  85,  70, 100 }, 
	                    { 60,  30,  40,  50 }, 
	                    { 50,  60,  70,  45 }, 
	                    { 80, 100,  90,  85 }, 
	                    { 75,  90,  55,  80 }, 
	};

	return 0;
}


結果：
学生0の平均点 81.250000 
学生1の平均点 45.000000 
学生2の平均点 56.250000 
学生3の平均点 88.750000 
学生4の平均点 75.000000 

0回目の試験の平均点 67.000000 
1回目の試験の平均点 73.000000 
2回目の試験の平均点 65.000000 
3回目の試験の平均点 72.000000 

習得した内容・反省・考察など：
forループを使った二重ループによって、数列の各要素の総和を求めることができた。行と列の値を混同してしまっているため、適切に変数を定義して間違えないようにしていきたい。

-----------------------------------------------
(E7_8*) 

学習内容：

結果：

習得した内容・反省・考察など：

-----------------------------------------------
[E7] 全体に対する感想などを以下に記すこと．
所要時間： （3）時間
今回の課題では、前回に引き続いて配列について勉強することができた。主に、配列同士を計算したり、配列の各要素を計算するような課題が多かったが、線形代数から少し離れていたこともあり、プログラムを作成する前に、計算で少し躓いてしまうことがあった。コードを書きながら、復習することで思い出すことができたが、一年生の時にあまり勉強できていなかったツケが回ってきてしまっていると感じる。もう中間テストも近づいてきているため、先生のビデオと一緒に教科書を復習しておこうと思う。


